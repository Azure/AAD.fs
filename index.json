[{"uri":"https://github.com/Azure/AAD.fs/index.html","title":"AAD.fs\n","content":"(** AAD.fs\n======================\nThe library implements core abstractions that can be used to authorize access to web APIs implemented in Giraffe or Suave with Azure Active Directory, as well as primitives to implement authorization for other servers.\n\nConcepts\n---------------\n### Requesting Party\nA user, a service principal (AD Enterprise Application) or a client (AD Application) acting on behalf of a user.\n\n### Resource Server\nSuave or Giraffe server hosting the HTTP endpoints.\n\n### Roles and scopes\nA role is a computed value based on the scope in the request for a token and returned by AD as a claim in the token.\nIt can be an AD Role (\u0060role\u0060 claim), an AD Application role (\u0060roles\u0060 claim) or a plain \u0060scp\u0060 scope - all of them will be evaluated by default. \n\n### Authorization\n\n![flow](content/flow.svg)\n\n1. When building the application routes construct a \u0060PartProtector\u0060\n1. By default well-known URI of the AD authority will be contacted\n1. Retrieved the signing keys will be used later to verify tokens\n1. Requesting party requests a token, for example using assigned [application roles](https://docs.microsoft.com/en-us/azure/architecture/multitenant-identity/app-roles)\n1. Pass the resulting token along with the http request in \u0060Authorization\u0060 header\n1. Pass the call to \u0060PartProtector.Verify\u0060 - a \u0060WebPart\u0060 that implements the validation\n1. \u0060PartProtector\u0060 asks for demands given the context of the request\n1. \u0060Demand\u0060 is a recursive data stucture, a simple single value can be captured in a \u0060Pattern\u0060\n1. \u0060PartProtector\u0060 checks the token and if matches the claims to the demands\n1. If successful passes the validated token along into the user\u0027s \u0060WebPart\u0060\n1. If unsuccessful returns either auto-generated or user-specified \u0060WebPart\u0060 for the error\n\n\u003C/br\u003E\n\nFor the Giraffe example walkthrough see the [sample](https://azure.github.io/AAD.fs/sample.html).\n\n\u003C/br\u003E\n \nContributing and copyright\n--------------------------\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork \nthe project and submit pull requests. \n\nThe library is available under MIT license, which allows modification and \nredistribution for both commercial and non-commercial purposes. For more information see the \n[License file][license] in the GitHub repository. \n\n  [content]: https://github.com/Azure/AAD.fs/tree/master/docs/content\n  [gh]: https://github.com/Azure/AAD.fs\n  [issues]: https://github.com/Azure/AAD.fs/issues\n  [readme]: https://github.com/Azure/AAD.fs/blob/master/README.md\n  [license]: https://github.com/Azure/AAD.fs/blob/master/LICENSE.md\n\n*)\n\n"},{"uri":"https://github.com/Azure/AAD.fs/sample.html","title":"sample","content":"(*** hide ***)\n#I \u0022../AAD.tasks.Test/bin/Debug/net5.0\u0022\n#r \u0022TaskBuilder.fs.dll\u0022\n#r \u0022AAD.Giraffe.dll\u0022\n#r \u0022AAD.fs.tasks.dll\u0022\n#r \u0022Giraffe.dll\u0022\nopen System\nopen FSharp.Control.Tasks.V2.ContextInsensitive\nopen Giraffe\nopen AAD\nlet httpClient = new Net.Http.HttpClient()\nlet audience = [\u0022\u0022]\nlet authority = Uri(\u0022\u0022)\n\n(** The sample\n---------\nThe example implements authorization using [Azure Application Roles](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps). The sample application can be found in your Azure Active Directory once provisioned:\n\n- \u0060dotnet fake build -t registerSample\u0060\n\nFor simplicity, the sample uses service principals as identities for the Requesting Party. The registration creates following items in the AD:\n\n- \u0060aad-sample-admin\u0060 service principal (Requesting Party) \n- \u0060aad-sample-reader\u0060 service principal (Requesting Party)\n- \u0060aad-sample-writer\u0060 service principal (Requesting Party)\n- \u0060aad-fs-sample\u0060 application (Resource Server) and corresponging Enterprise Application to manage application role assignments \n\n\u003E Note: All the identitifiers will have a random suffix added.\n\n\u0060aad-sample\u0060 will have following AppRoles defined:\n\n- \u0060Admin\u0060 with \u0060*/*\u0060 value\n- \u0060Reader\u0060 with \u0060items/r\u0060 value\n- \u0060Writer\u0060 with \u0060items/w\u0060 value\n\nOnce provisioned you can find these roles in the application\u0027s manifest, it will look something like this:\n\n![appRoles](content/manifest_roles.png)\n\n\nRequesting Party service principals will have the corresponding roles assigned, which you can check in the Enterprise Application\u0027s \u0060Users and Groups\u0060 blade:\n\n![assignments](content/assignments.png)\n\n\nAuthoring the roles\n---------\nThe role values can be anything you need. The example here demonstrates the capability of the library to deal with patterns and wildcards:\n\nA \u0022pattern\u0022 means that we can expect a structure in the value, like \u0022items/r\u0022 or \u0022items.r\u0022 - \u0060/\u0060 is the default separator, but the character is configurable - use \u0060PartProtector.mkNew\u0060 instead of \u0060mkDefault\u0060 if you need to change it. \u003C/br\u003E\nUse \u0060*\u0060 wildcard in any segment of the role value to make any demand match that part of the pattern, for example \u0060items/*\u0060 in the role value will match the demands like \u0060items/r\u0060, \u0060items/w\u0060, etc. \u003C/br\u003E\n\u0060*/*\u0060 means that the identity with that claim in the token will have access to APIs that demand \u0060items\u0060, \u0060fiddles/play\u0060, \u0060cats/herd\u0060, etc with or w/o any 2nd (verb) segment.\n\nComplex demands can be expressed by combining the patterns with \u0060Any\u0060 and \u0060All\u0060, for example:\n\n- \u0060All [Pattern [\u0022A\u0022;\u00221\u0022]; Pattern [\u0022B\u0022;\u00222\u0022]]\u0060 will only match if both \u0060A/1\u0060 and \u0060B/2\u0060 are present among the token claims. \n*)\n\n\n(** Implementing Resource Server\n---------\nThe full source code for this sample is in \u0060AAD.tasks.Test/ResourceServers.fs\u0060, but here are the important ingredients:\n*)\n\ntask {\n    let! protector : PartProtector = \n        PartProtector.mkDefault httpClient audience authority\n        \n    let read : HttpHandler =\n        protector.Verify (fun ctx -\u003E Task.FromResult \u003C| Pattern [\u0022items\u0022; \u0022r\u0022])\n                         (fun token -\u003E text \u0022Read!\u0022)\n\n    let write : HttpHandler =\n        protector.Verify (fun ctx -\u003E Task.FromResult \u003C| Pattern [\u0022items\u0022; \u0022w\u0022])\n                         (fun token -\u003E text \u0022Written!\u0022)\n        \n    return \n        choose [\n          HEAD \u003E=\u003E route \u0022/\u0022 \u003E=\u003E Successful.NO_CONTENT\n          GET \u003E=\u003E route \u0022/\u0022 \u003E=\u003E read\n          PUT \u003E=\u003E route \u0022/\u0022 \u003E=\u003E write\n          RequestErrors.NOT_FOUND \u0022\u0022\n        ]\n}\n\n(** \nAs you can see:\n\n- all the tokens that \u0060protector\u0060 handles are issued for a specific \u0060audience\u0060 - our \u0060aad-fs-sample\u0060 \n- the functions that return the demands for a given handler are asynchronous to facilitate potential IO based on the context of the request.\n- \u0060read\u0060 HttpHandler demands access with a token that has a claim in one of [\u0060role\u0060, \u0060roles\u0060 or \u0060scp\u0060] that matches the pattern \u0060items/r\u0060 \n- \u0060write\u0060 HttpHandler demands access with a token that has a claim that matches the pattern \u0060items/w\u0060\n\nAnd as mentioned above, \u0060Admin\u0060 with its \u0060*/*\u0060 value will meet both of those demands.\n*)\n\n\n(** Requesting the token\n---------\nOn the Requesting Party side, we need to tell the AD that we need the appRoles assigned to our principals mapped to the token claims.\nWe do that by specifying our \u0060Application URI\u0060 as a scope, in case of the registerd sample it will look something like: \u0060api://{clientid}/.default\u0060, where the \u0060/.default\u0060 suffix is a special identifier that tells AD to figure which role(s) the user has in the application instead of requesting one specific role. \nThe samples use [MSAL](https://github.com/AzureAD/microsoft-authentication-library-for-dotnet) to obtain and refresh the token as needed.\n*)\n\n\n(** Passing the token with a call\n---------\nConsidering that the token is refreshed periodically, \u0060AsyncRequestor\u0060 or \u0060TaskRequestor\u0060 can be useful to ensure a token is obtained and associated it with each request.   \n*)"}]